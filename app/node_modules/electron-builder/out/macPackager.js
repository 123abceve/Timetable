"use strict";

const platformPackager_1 = require("./platformPackager");
const metadata_1 = require("./metadata");
const path = require("path");
const bluebird_1 = require("bluebird");
const util_1 = require("./util");
const codeSign_1 = require("./codeSign");
const fs_extra_p_1 = require("fs-extra-p");
const _7zip_bin_1 = require("7zip-bin");
const deepAssign = require("deep-assign");
//noinspection JSUnusedLocalSymbols
const __awaiter = require("./awaiter");
class MacPackager extends platformPackager_1.PlatformPackager {
    constructor(info, cleanupTasks) {
        super(info);
        if (this.options.cscLink != null && this.options.cscKeyPassword != null) {
            const keychainName = codeSign_1.generateKeychainName();
            cleanupTasks.push(() => codeSign_1.deleteKeychain(keychainName));
            this.codeSigningInfo = codeSign_1.createKeychain(keychainName, this.options.cscLink, this.options.cscKeyPassword, this.options.csaLink);
        } else {
            this.codeSigningInfo = bluebird_1.Promise.resolve(null);
        }
    }
    get platform() {
        return metadata_1.Platform.OSX;
    }
    pack(outDir, appOutDir, arch) {
        const _super = name => super[name];
        return __awaiter(this, void 0, void 0, function* () {
            yield _super("pack").call(this, outDir, appOutDir, arch);
            const codeSigningInfo = yield this.codeSigningInfo;
            yield this.signMac(path.join(appOutDir, this.appName + ".app"), codeSigningInfo);
        });
    }
    signMac(distPath, codeSigningInfo) {
        if (codeSigningInfo == null) {
            codeSigningInfo = { cscName: this.options.sign || process.env.CSC_NAME };
        }
        if (codeSigningInfo.cscName == null) {
            util_1.log("App is not signed: CSC_LINK or CSC_NAME are not specified");
            return bluebird_1.Promise.resolve();
        } else {
            util_1.log("Signing app");
            return codeSign_1.sign(distPath, codeSigningInfo);
        }
    }
    packageInDistributableFormat(outDir, appOutDir) {
        const artifactPath = path.join(appOutDir, `${ this.appName }-${ this.metadata.version }.dmg`);
        return bluebird_1.Promise.all([new bluebird_1.Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            util_1.log("Creating DMG");
            const specification = deepAssign({
                title: this.appName,
                icon: path.join(this.buildResourcesDir, "icon.icns"),
                "icon-size": 80,
                contents: [{
                    "x": 410, "y": 220, "type": "link", "path": "/Applications"
                }, {
                    "x": 130, "y": 220, "type": "file"
                }]
            }, this.customBuildOptions);
            if (this.customBuildOptions == null || !("background" in this.customBuildOptions)) {
                const background = path.join(this.buildResourcesDir, "background.png");
                try {
                    if ((yield fs_extra_p_1.stat(background)).isFile()) {
                        specification.background = background;
                    }
                } catch (e) {}
            }
            specification.contents[1].path = path.join(appOutDir, this.appName + ".app");
            const emitter = require("appdmg")({
                target: artifactPath,
                basepath: this.projectDir,
                specification: specification
            });
            emitter.on("error", reject);
            emitter.on("finish", () => resolve());
        })).then(() => this.dispatchArtifactCreated(artifactPath, `${ this.metadata.name }-${ this.metadata.version }.dmg`)), this.zipMacApp(appOutDir).then(it => this.dispatchArtifactCreated(it, `${ this.metadata.name }-${ this.metadata.version }-mac.zip`))]);
    }
    zipMacApp(outDir) {
        util_1.log("Creating ZIP for Squirrel.Mac");
        // we use app name here - see https://github.com/electron-userland/electron-builder/pull/204
        const resultPath = `${ this.appName }-${ this.metadata.version }-mac.zip`;
        // -y param is important - "store symbolic links as the link instead of the referenced file"
        const args = ["a", "-mm=" + (this.devMetadata.build.compression === "store" ? "Copy" : "Deflate"), "-r", "-bb0", "-bd"];
        if (this.devMetadata.build.compression === "maximum") {
            // http://superuser.com/a/742034
            //noinspection SpellCheckingInspection
            args.push("-mfb=258", "-mpass=15");
        }
        args.push(resultPath, this.appName + ".app");
        return util_1.spawn(_7zip_bin_1.path7za, args, {
            cwd: outDir,
            stdio: ["ignore", "ignore", "inherit"]
        }).thenReturn(path.join(outDir, resultPath));
    }
}
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = MacPackager;
//# sourceMappingURL=macPackager.js.map