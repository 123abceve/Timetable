"use strict";

const metadata_1 = require("./metadata");
const bluebird_1 = require("bluebird");
const path = require("path");
const packager = require("electron-packager-tf");
const globby = require("globby");
const fs_extra_p_1 = require("fs-extra-p");
const util_1 = require("./util");
const deepAssign = require("deep-assign");
//noinspection JSUnusedLocalSymbols
const __awaiter = require("./awaiter");
const pack = bluebird_1.Promise.promisify(packager);
class PlatformPackager {
    constructor(info) {
        this.info = info;
        this.options = info.options;
        this.projectDir = info.projectDir;
        this.metadata = info.metadata;
        this.devMetadata = info.devMetadata;
        this.buildResourcesDir = path.resolve(this.projectDir, this.relativeBuildResourcesDirname);
        this.customBuildOptions = info.devMetadata.build[this.platform.buildConfigurationKey];
        this.appName = metadata_1.getProductName(this.metadata, this.devMetadata);
    }
    get platform() {}
    get relativeBuildResourcesDirname() {
        return use(this.devMetadata.directories, it => it.buildResources) || "build";
    }
    dispatchArtifactCreated(file, artifactName) {
        this.info.eventEmitter.emit("artifactCreated", {
            file: file,
            artifactName: artifactName,
            platform: this.platform
        });
    }
    pack(outDir, appOutDir, arch) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.doPack(outDir, appOutDir, arch);
            yield this.copyExtraResources(appOutDir, arch);
        });
    }
    doPack(outDir, appOutDir, arch) {
        return __awaiter(this, void 0, void 0, function* () {
            const version = this.metadata.version;
            let buildVersion = version;
            const buildNumber = this.computeBuildNumber();
            if (buildNumber != null) {
                buildVersion += "." + buildNumber;
            }
            checkConflictingOptions(this.devMetadata.build);
            const options = deepAssign({
                dir: this.info.appDir,
                out: outDir,
                name: this.appName,
                platform: this.platform.nodeName,
                arch: arch,
                version: this.info.electronVersion,
                icon: path.join(this.buildResourcesDir, "icon"),
                asar: true,
                overwrite: true,
                "app-version": version,
                "build-version": buildVersion,
                tmpdir: false,
                "version-string": {
                    CompanyName: this.metadata.author.name,
                    FileDescription: this.metadata.description,
                    ProductName: this.appName,
                    InternalName: this.appName
                }
            }, this.devMetadata.build);
            delete options.osx;
            delete options.win;
            delete options.linux;
            // this option only for windows-installer
            delete options.iconUrl;
            yield pack(options);
            const outStat = yield util_1.statOrNull(appOutDir);
            if (outStat == null) {
                throw new Error(`Output directory ${ appOutDir } does not exists. Seems like a wrong configuration.`);
            } else if (!outStat.isDirectory()) {
                throw new Error(`Output directory ${ appOutDir } is a file. Seems like a wrong configuration.`);
            }
        });
    }
    getExtraResources(arch) {
        const buildMetadata = this.devMetadata.build;
        let extraResources = buildMetadata == null ? null : buildMetadata.extraResources;
        const platformSpecificExtraResources = this.customBuildOptions == null ? null : this.customBuildOptions.extraResources;
        if (platformSpecificExtraResources != null) {
            extraResources = extraResources == null ? platformSpecificExtraResources : extraResources.concat(platformSpecificExtraResources);
        }
        if (extraResources == null) {
            return bluebird_1.Promise.resolve([]);
        }
        const expandedPatterns = extraResources.map(it => it.replace(/\$\{arch}/g, arch).replace(/\$\{os}/g, this.platform.buildConfigurationKey));
        return globby(expandedPatterns, { cwd: this.projectDir });
    }
    copyExtraResources(appOutDir, arch) {
        return __awaiter(this, void 0, void 0, function* () {
            let resourcesDir = appOutDir;
            if (this.platform === metadata_1.Platform.OSX) {
                resourcesDir = path.join(resourcesDir, this.appName + ".app", "Contents", "Resources");
            }
            return yield bluebird_1.Promise.map((yield this.getExtraResources(arch)), it => fs_extra_p_1.copy(path.join(this.projectDir, it), path.join(resourcesDir, it)));
        });
    }
    computePackageUrl() {
        return __awaiter(this, void 0, void 0, function* () {
            const url = this.devMetadata.homepage;
            if (url != null) {
                return url;
            }
            if (this.info.repositoryInfo != null) {
                const info = yield this.info.repositoryInfo.getInfo(this);
                if (info != null) {
                    return `https://github.com/${ info.user }/${ info.project }`;
                }
            }
            return null;
        });
    }
    computeBuildNumber() {
        return this.devMetadata.build["build-version"] || process.env.TRAVIS_BUILD_NUMBER || process.env.APPVEYOR_BUILD_NUMBER || process.env.CIRCLE_BUILD_NUM;
    }
}
exports.PlatformPackager = PlatformPackager;
function checkConflictingOptions(options) {
    for (let name of ["all", "out", "tmpdir", "version", "platform", "dir", "arch"]) {
        if (name in options) {
            throw new Error(`Option ${ name } is ignored, do not specify it.`);
        }
    }
}
function use(value, task) {
    return value == null ? null : task(value);
}
exports.use = use;
//# sourceMappingURL=platformPackager.js.map